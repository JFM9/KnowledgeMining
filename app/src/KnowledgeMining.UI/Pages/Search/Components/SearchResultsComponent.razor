@using KnowledgeMining.Application.Documents.Queries.SearchDocuments
@if (IsLoading)
{
    <MudGrid>
        <MudItem xs="12" sm="5">
            <MudCard Outlined="true">
                <MudCardContent Class="d-flex flex-column align-content-start">
                    <div class="d-flex flex-row flex-fill gap-2">
                        <div>
                            <MudSkeleton SkeletonType="SkeletonType.Circle" Animation="Animation.Wave" Height="40px" Width="40px"/>
                        </div>
                        <div class="d-flex flex-column">
                            <div>
                                <MudSkeleton Width="100px" Animation="Animation.Wave" />
                            </div>
                            <div class="d-flex flex-row flex-wrap pt-1 flex-shrink-0">
                                @foreach (var keyPhrase in Enumerable.Range(1, 4))
                                {
                                    <MudSkeleton Width="150px" Style="pa-5" Animation="Animation.Wave" SkeletonType="SkeletonType.Text" />
                                }
                            </div>
                        </div>
                    </div>
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
}
else
{
    @if (TotalCount > 0)
    {
        <MudToolBar Class="d-flex; flex-row-reverse" DisableGutters="true">
            <MudMenu StartIcon="@Icons.Filled.Check" Label="@_sortLabel">
                <MudMenuItem OnClick="@SortBestMatchClicked">Best Match</MudMenuItem>
                <MudMenuItem OnClick="@SortDateClicked">Date</MudMenuItem>
            </MudMenu>
        </MudToolBar>
        <MudGrid>
            @foreach (var document in Documents)
            {
                <MudItem xs="12" sm="12">
                    <MudCard Outlined="true" @onclick="() => OnDocumentClicked.InvokeAsync(document.Id)" Style="cursor: pointer;">
                        <MudCardContent Class="d-flex flex-column align-content-start">
                            <div class="d-flex flex-row flex-fill gap-2">
                                <div class="d-flex flex-column flex-fill">
                                    <div class="d-flex flex-row justify-content-between">
                                        <h6><MudIcon Icon="@Icons.Custom.FileFormats.FileDocument"></MudIcon> @DocumentHeader(document)</h6>
                                        <h6>@(document.DateTime?.ToLongDateString() ?? string.Empty)</h6>
                                    </div>
                                    <div class="d-flex flex-row mt-2 mb-2" style="text-overflow: ellipsis; max-height: 60px; overflow: hidden;">
                                        @DocumentSummary(document)
                                    </div>
                                    <div class="d-flex flex-row flex-wrap pt-1 flex-shrink-0">
                                        @foreach (var keyPhrase in document.KeyPhrases.Take(8))
                                        {
                                            <MudChip Color="Color.Info"><MudText Typo="Typo.body2">@keyPhrase</MudText></MudChip>
                                        }
                                    </div>
                                    <div class="d-flex flex-row justify-content-between mt-2">
                                        <small>Score: @document.SearchScore</small>
                                        <small>@DocumentFooter(document)</small>
                                    </div>
                                </div>
                            </div>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
        <div class="d-flex align-center flex-column pt-4">
            <MudPagination Color="Color.Primary" Count="@(TotalPages ?? 0)" SelectedChanged="@HandlePageSelected" Selected="@(GetSelectedPage())" />            
        </div>
    }
    else
    {
        <MudContainer Fixed="true" Class="d-flex align-center flex-column">
            <MudText>No documents found</MudText>
        </MudContainer>
    }
}

@code {
    [Parameter]
    public IEnumerable<DocumentMetadata>? Documents { get; set; }
    [Parameter]
    public long? TotalCount { get; set; }
    [Parameter]
    public int? TotalPages { get; set; }

    [Parameter]
    public EventCallback<string> OnDocumentClicked { get; set; }

    [Parameter]
    public int? PageSelected { get; set; }

    [Parameter]
    public EventCallback<int> OnPageSelectedChanged { get; set; }

    [Parameter]
    public bool IsLoading { get; set; }

    [Parameter]
    public EventCallback<FacetFilter?> SortCallBack { get; set; }

    private const string LABEL_ORDERBY_BEST_MATCH = "Best Match";
    private const string LABEL_ORDERBY_DATE = "Date";
    private string _sortLabel = LABEL_ORDERBY_BEST_MATCH;

    private int GetSelectedPage()
    {
        if(PageSelected.HasValue && PageSelected.Value > 0)
        {
            return PageSelected.Value;
        }
        return 1;
    }

    private Task HandlePageSelected(int page)
    {
        if(GetSelectedPage() != page)
        {
            return OnPageSelectedChanged.InvokeAsync(page);
        }
        else
        {
            return Task.CompletedTask;
        }
    }

    private string DocumentHeader(DocumentMetadata document)
    {
        if (!string.IsNullOrWhiteSpace(document.Mission))
            return document.Mission;

        return document.Name;
    }

    private string DocumentSummary(DocumentMetadata document)
    {
        var summary = document.Summary ?? string.Empty;

        if (summary.Length > 203)
            summary = summary.Substring(0, 200) + "...";

        return summary;
    }

    private string DocumentFooter(DocumentMetadata document)
    {
        if (!string.IsNullOrWhiteSpace(document.Name))
            return document.Name;

        return string.Empty;
    }

    private async Task SortBestMatchClicked(MouseEventArgs args)
    {
        _sortLabel = LABEL_ORDERBY_BEST_MATCH;
        await SortCallBack.InvokeAsync(OrderByFacetFilter.BestMatch());
    }

    private async Task SortDateClicked(MouseEventArgs args)
    {
        _sortLabel = LABEL_ORDERBY_DATE;
        await SortCallBack.InvokeAsync(OrderByFacetFilter.Date());
    }

    public void ClearOrder()
    {
        _sortLabel = LABEL_ORDERBY_BEST_MATCH;
    }
}